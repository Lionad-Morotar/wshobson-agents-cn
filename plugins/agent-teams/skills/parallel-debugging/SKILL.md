---
name: parallel-debugging
description: 使用竞争假设和并行调查、证据收集及根本原因仲裁来调试复杂问题。在调试具有多个潜在原因的 bug、执行根本原因分析或组织并行调查工作流程时使用此技能。
version: 1.0.2
---

# 并行调试

使用竞争假设分析(ACH)方法和并行智能体调查调试复杂问题的框架。

## 何时使用此技能

- Bug 有多个合理的根本原因
- 初始调试尝试未识别问题
- 问题跨越多个模块或组件
- 需要有证据的系统根本原因分析
- 希望避免调试中的确认偏差

## 假设生成框架

跨 6 个失败模式类别生成假设:

### 1. 逻辑错误

- 错误的条件逻辑(错误的运算符、缺失的情况)
- 循环或数组访问中的差一错误
- 缺失边缘情况处理
- 错误的算法实现

### 2. 数据问题

- 无效或意外的输入数据
- 类型不匹配或强制转换错误
- 需要值的地方有 null/undefined/None
- 编码或序列化问题
- 数据截断或溢出

### 3. 状态问题

- 并发操作之间的竞态条件
- 陈旧缓存返回过期数据
- 错误的初始化或默认值
- 共享状态的意外变异
- 状态机转换错误

### 4. 集成失败

- API 契约违反(请求/响应不匹配)
- 组件之间的版本不兼容
- 环境之间的配置不匹配
- 缺失或错误的环境变量
- 网络超时或连接失败

### 5. 资源问题

- 内存泄漏导致逐渐退化
- 连接池耗尽
- 文件描述符或句柄泄漏
- 磁盘空间或配额超出
- 低效处理导致的 CPU 饱和

### 6. 环境

- 缺失运行时依赖
- 错误的库或框架版本
- 平台特定的行为差异
- 权限或访问控制问题
- 时区或区域设置相关行为

## 证据收集标准

### 什么构成证据

| 证据类型         | 强度   | 示例                                                         |
| ---------------- | ------ | ------------------------------------------------------------ |
| **直接**         | 强     | `file.ts:42` 的代码显示 `if (x > 0)` 应该是 `if (x >= 0)`     |
| **相关性**       | 中     | 提交 `abc123` 后错误率增加                                    |
| **证词**         | 弱     | "在我的机器上可以工作"                                       |
| **缺失**         | 可变   | 代码路径中未找到 null 检查                                    |

### 引用格式

始终使用 file:line 引用引用证据:

```
**证据**: `src/validators/user.ts:87` 的验证函数
不检查空字符串,只检查 null/undefined。这允许
空电子邮件地址通过验证。
```

### 置信度水平

| 水平             | 标准                                                              |
| ---------------- | ----------------------------------------------------------------- |
| **高(>80%)**     | 多个直接证据,清晰的因果链,没有矛盾证据                             |
| **中(50-80%)**   | 一些直接证据,合理的因果链,轻微的歧义                               |
| **低(<50%)**     | 主要是相关性证据,不完整的因果链,一些矛盾证据                       |

## 结果仲裁协议

所有调查者报告后:

### 步骤 1:分类结果

- **已确认**: 高置信度,强证据,清晰的因果链
- **合理**: 中置信度,一些证据,合理的因果链
- **已证伪**: 证据与假设矛盾
- **无结论**: 证据不足以确认或证伪

### 步骤 2:比较已确认的假设

如果多个假设已确认,按以下排名:

1. 置信度水平
2. 支持证据数量
3. 因果链强度
4. 缺乏矛盾证据

### 步骤 3:确定根本原因

- 如果一个假设明显占优势:声明为根本原因
- 如果多个假设同样可能:可能是复合问题(多个促成原因)
- 如果没有确认假设:基于收集的证据生成新假设

### 步骤 4:验证修复

在声明 bug 已修复之前:

- [ ] 修复解决了识别的根本原因
- [ ] 修复不会引入新问题
- [ ] 原始重现场例不再失败
- [ ] 相关边缘情况已覆盖
- [ ] 相关测试已添加或更新
