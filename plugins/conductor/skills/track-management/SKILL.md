---
name: track-management
description: 使用此技能来创建、管理或处理 Conductor tracks——功能、bug 和重构的逻辑工作单元。适用于 spec.md、plan.md 和 track 生命周期操作。
version: 1.0.0
---

# Track 管理

用于创建、管理和完成 Conductor tracks 的指南——这些逻辑工作单元通过规范、计划和实施阶段组织功能、bug 和重构。

## 何时使用此技能

- 创建新功能、bug 或重构 tracks
- 编写或审查 spec.md 文件
- 创建或更新 plan.md 文件
- 管理从创建到完成的 track 生命周期
- 理解 track 状态标记和约定
- 使用 tracks.md 注册表
- 解释或更新 track 元数据

## Track 概念

Track 是封装完整工作单元的逻辑工作单位。每个 track 具有：

- 唯一标识符
- 定义需求的规范
- 将工作分解为任务的分阶段计划
- 跟踪状态和进度的元数据

Tracks 为工作提供语义组织，实现：

- 清晰的边界范围
- 进度跟踪
- Git 感知操作（按 track 撤销）
- 团队协作

## Track 类型

### feature（功能）

新功能或能力。用于：

- 面向用户的新功能
- 新 API 端点
- 新集成
- 重大增强

### bug（缺陷）

缺陷修复。用于：

- 错误行为
- 错误条件
- 性能回归
- 安全漏洞

### chore（杂务）

维护和清理。用于：

- 依赖项更新
- 配置更改
- 文档更新
- 清理任务

### refactor（重构）

不改变行为的代码改进。用于：

- 代码重组
- 模式采用
- 技术债务减少
- 性能优化（相同行为，更好性能）

## Track ID 格式

Track ID 遵循模式：`{shortname}_{YYYYMMDD}`

- **shortname**：2-4 个单词的 kebab-case 描述（例如 `user-auth`、`api-rate-limit`）
- **YYYYMMDD**：ISO 格式的创建日期

示例：

- `user-auth_20250115`
- `fix-login-error_20250115`
- `upgrade-deps_20250115`
- `refactor-api-client_20250115`

## Track 生命周期

### 1. 创建

**定义需求**

1. 通过交互式问答收集需求
2. 确定验收标准
3. 确定范围边界
4. 识别依赖关系

**生成规范**

1. 创建带有结构化需求的 `spec.md`
2. 记录功能和非功能需求
3. 定义验收标准
4. 列出依赖关系和约束

**生成计划**

1. 创建带有分阶段任务分解的 `plan.md`
2. 将任务组织到逻辑阶段中
3. 在阶段后添加验证任务
4. 估算工作量和复杂性

**注册 Track**

1. 在 `tracks.md` 注册表中添加条目
2. 创建 track 目录结构
3. 生成 `metadata.json`
4. 创建 track `index.md`

### 2. 实施

**执行任务**

1. 从计划中选择下一个待处理任务
2. 将任务标记为进行中
3. 按照工作流程（TDD）实施
4. 使用提交 SHA 标记任务完成

**更新状态**

1. 更新 plan.md 中的任务标记
2. 记录提交 SHA 以便跟踪
3. 更新阶段进度
4. 更新 tracks.md 中的 track 状态

**验证进度**

1. 完成验证任务
2. 等待检查点批准
3. 记录检查点提交

### 3. 完成

**同步文档**

1. 如果添加了功能，更新 product.md
2. 如果依赖项更改，更新 tech-stack.md
3. 验证所有验收标准已满足

**归档或删除**

1. 在 tracks.md 中将 track 标记为已完成
2. 记录完成日期
3. 归档或保留 track 目录

## 规范（spec.md）结构

```markdown
# {Track 标题}

## 概述

简要描述此 track 完成的内容和原因。

## 功能需求

### FR-1：{需求名称}

功能需求描述。

- 验收：如何验证此需求已满足

### FR-2：{需求名称}

...

## 非功能需求

### NFR-1：{需求名称}

非功能需求描述（性能、安全性等）

- 目标：具体可测量目标
- 验证：如何测试

## 验收标准

- [ ] 标准 1：具体、可测试的条件
- [ ] 标准 2：具体、可测试的条件
- [ ] 标准 3：具体、可测试的条件

## 范围

### 包含范围内

- 明确包含的项目
- 要实施的功能
- 要修改的组件

### 超出范围

- 明确排除的项目
- 未来考虑
- 相关但独立的工作

## 依赖关系

### 内部

- 此 track 依赖的其他 tracks 或组件
- 所需的上下文工件

### 外部

- 第三方服务或 API
- 外部依赖项

## 风险和缓解措施

| 风险             | 影响          | 缓解措施          |
| ---------------- | --------------- | ------------------- |
| 风险描述 | 高/中/低 | 缓解策略 |

## 未决问题

- [ ] 需要解决的问题
- [x] 已解决的问题 - 答案
```

## 计划（plan.md）结构

```markdown
# 实施计划：{Track 标题}

Track ID：`{track-id}`
创建：YYYY-MM-DD
状态：pending | in-progress | completed

## 概述

实施方法简要描述。

## 阶段 1：{阶段名称}

### 任务

- [ ] **任务 1.1**：任务描述
  - 子任务或细节
  - 子任务或细节
- [ ] **任务 1.2**：任务描述
- [ ] **任务 1.3**：任务描述

### 验证

- [ ] **验证 1.1**：阶段的验证步骤

## 阶段 2：{阶段名称}

### 任务

- [ ] **任务 2.1**：任务描述
- [ ] **任务 2.2**：任务描述

### 验证

- [ ] **验证 2.1**：阶段的验证步骤

## 阶段 3：最终化

### 任务

- [ ] **任务 3.1**：更新文档
- [ ] **任务 3.2**：最终集成测试

### 验证

- [ ] **验证 3.1**：所有验收标准已满足

## 检查点

| 阶段   | 检查点 SHA | 日期 | 状态  |
| ------- | -------------- | ---- | ------- |
| 阶段 1 |                |      | pending |
| 阶段 2 |                |      | pending |
| 阶段 3 |                |      | pending |
```

## 状态标记约定

在 plan.md 中使用一致的标记：

| 标记 | 含义     | 用途                       |
| ------ | ----------- | --------------------------- |
| `[ ]`  | 待处理     | 任务未开始            |
| `[~]`  | 进行中 | 当前正在工作      |
| `[x]`  | 已完成    | 任务已完成（包含 SHA） |
| `[-]`  | 已跳过     | 故意不做      |
| `[!]`  | 已阻塞     | 等待依赖       |

示例：

```markdown
- [x] **任务 1.1**：设置数据库模式 `abc1234`
- [~] **任务 1.2**：实施用户模型
- [ ] **任务 1.3**：添加验证逻辑
- [!] **任务 1.4**：集成身份验证服务（已阻塞：等待 API 密钥）
- [-] **任务 1.5**：旧版迁移（已跳过：不需要）
```

## Track 注册表（tracks.md）格式

```markdown
# Track 注册表

## 活跃 Tracks

| Track ID                                         | 类型    | 状态      | 阶段 | 开始时间    | 负责人   |
| ------------------------------------------------ | ------- | ----------- | ----- | ---------- | ---------- |
| [user-auth_20250115](tracks/user-auth_20250115/) | feature | in-progress | 2/3   | 2025-01-15 | @developer |
| [fix-login_20250114](tracks/fix-login_20250114/) | bug     | pending     | 0/2   | 2025-01-14 | -          |

## 已完成 Tracks

| Track ID                                       | 类型  | 完成时间  | 持续时间 |
| ---------------------------------------------- | ----- | ---------- | -------- |
| [setup-ci_20250110](tracks/setup-ci_20250110/) | chore | 2025-01-12 | 2 天   |

## 已归档 Tracks

| Track ID                                             | 原因     | 归档时间   |
| ---------------------------------------------------- | ---------- | ---------- |
| [old-feature_20241201](tracks/old-feature_20241201/) | 被取代 | 2025-01-05 |
```

## 元数据（metadata.json）字段

```json
{
  "id": "user-auth_20250115",
  "title": "用户身份验证系统",
  "type": "feature",
  "status": "in-progress",
  "priority": "high",
  "created": "2025-01-15T10:30:00Z",
  "updated": "2025-01-15T14:45:00Z",
  "started": "2025-01-15T11:00:00Z",
  "completed": null,
  "assignee": "@developer",
  "phases": {
    "total": 3,
    "current": 2,
    "completed": 1
  },
  "tasks": {
    "total": 12,
    "completed": 5,
    "in_progress": 1,
    "pending": 6
  },
  "checkpoints": [
    {
      "phase": 1,
      "sha": "abc1234",
      "date": "2025-01-15T13:00:00Z"
    }
  ],
  "dependencies": [],
  "tags": ["auth", "security"]
}
```

## Track 操作

### 创建 Track

1. 运行 `/conductor:new-track`
2. 回答交互式问题
3. 审查生成的 spec.md
4. 审查生成的 plan.md
5. 确认 track 创建

### 开始实施

1. 阅读 spec.md 和 plan.md
2. 验证上下文工件是最新的
3. 将第一个任务标记为 `[~]`
4. 开始 TDD 工作流程

### 完成阶段

1. 确保所有阶段任务为 `[x]`
2. 完成验证任务
3. 等待检查点批准
4. 记录检查点 SHA
5. 进入下一阶段

### 完成 Track

1. 验证所有阶段已完成
2. 验证所有验收标准已满足
3. 如需要则更新 product.md
4. 在 tracks.md 中将 track 标记为已完成
5. 更新 metadata.json

### 撤销 Track

1. 运行 `/conductor:revert`
2. 选择要撤销的 track
3. 选择粒度（track/阶段/任务）
4. 确认撤销操作
5. 更新状态标记

## 处理 Track 依赖关系

### 识别依赖关系

在 track 创建期间，识别：

- **硬依赖**：在此 track 可以开始之前必须完成
- **软依赖**：可以并行进行但可能影响集成
- **外部依赖**：第三方服务、API 或团队决策

### 记录依赖关系

在 spec.md 中，列出依赖关系及：

- 依赖类型（硬/软/外部）
- 当前状态（可用/待处理/已阻塞）
- 解决路径（需要发生什么）

### 管理已阻塞的 Tracks

当 track 被阻塞时：

1. 使用 `[!]` 和原因标记已阻塞的任务
2. 更新 tracks.md 状态
3. 在 metadata.json 中记录阻塞项
4. 如需要则考虑创建依赖 track

## Track 大小指南

### 适当大小的 Tracks

目标是这样的 tracks：

- 1-5 天的工作完成
- 有 2-4 个阶段
- 总共包含 8-20 个任务
- 交付一个连贯的、可测试的单元

### 太大

track 太大的迹象：

- 超过 5 个阶段
- 超过 25 个任务
- 多个不相关的功能
- 估算持续时间 > 1 周

解决方案：拆分为具有清晰边界的多个 tracks。

### 太小

track 太小的迹象：

- 单个阶段，有 1-2 个任务
- 不需要有意义的验证
- 可以是另一个 track 的子任务
- 少于几个小时的工作

解决方案：与相关工作合并或作为现有 track 的一部分处理。

## 规范质量检查清单

在最终确定 spec.md 之前，验证：

### 需求质量

- [ ] 每个需求都有清晰的验收标准
- [ ] 需求是可测试的
- [ ] 需求是独立的（可以单独验证）
- [ ] 没有歧义的语言（"应该很快" → "响应 < 200ms"）

### 范围清晰度

- [ ] 范围内项目是具体的
- [ ] 范围外项目防止范围蔓延
- [ ] 实施者的边界清晰

### 已识别依赖关系

- [ ] 列出所有内部依赖
- [ ] 外部依赖有所有者/联系人
- [ ] 依赖状态是当前的

### 已处理风险

- [ ] 已识别主要风险
- [ ] 影响评估现实
- [ ] 缓解措施可操作

## 计划质量检查清单

在开始实施之前，验证 plan.md：

### 任务质量

- [ ] 任务是原子的（一个逻辑操作）
- [ ] 任务可独立验证
- [ ] 任务描述清晰
- [ ] 子任务提供有用的细节

### 阶段组织

- [ ] 阶段分组相关任务
- [ ] 每个阶段交付可测试的东西
- [ ] 每个阶段后有验证任务
- [ ] 阶段在逻辑上相互构建

### 完整性

- [ ] 所有规范需求都有相应的任务
- [ ] 包括文档任务
- [ ] 包括测试任务
- [ ] 包括集成任务

## 常见 Track 模式

### 功能 Track 模式

```
阶段 1：基础
- 数据模型
- 数据库迁移
- 基本 API 结构

阶段 2：核心逻辑
- 业务逻辑实施
- 输入验证
- 错误处理

阶段 3：集成
- UI 集成
- API 文档
- 端到端测试
```

### Bug 修复 Track 模式

```
阶段 1：复现
- 编写捕获 bug 的失败测试
- 记录复现步骤

阶段 2：修复
- 实施修复
- 验证测试通过
- 检查回归

阶段 3：验证
- 手动验证
- 如需要则更新文档
```

### 重构 Track 模式

```
阶段 1：准备
- 添加表征测试
- 记录当前行为

阶段 2：重构
- 增量应用更改
- 保持测试通过

阶段 3：清理
- 删除死代码
- 更新文档
```

## 最佳实践

1. **一个 track，一个关注点**：保持 tracks 专注于单个逻辑更改
2. **小阶段**：将工作分解为最多 3-5 个任务的阶段
3. **阶段后验证**：始终包括验证任务
4. **立即更新标记**：工作时标记任务状态
5. **记录 SHA**：始终注意已完成任务的提交 SHA
6. **计划前审查规范**：在创建计划之前确保规范完整
7. **链接依赖**：明确记录 track 依赖
8. **归档，不要删除**：保留已完成的 tracks 供参考
9. **适当大小**：保持 tracks 在 1-5 天的工作之间
10. **清晰的验收标准**：每个需求必须可测试
