---
name: context-driven-development
description: 使用此技能来处理 Conductor 的上下文驱动开发方法论，管理项目上下文工件，或理解 product.md、tech-stack.md 和 workflow.md 文件之间的关系。
version: 1.0.0
---

# 上下文驱动开发

将上下文作为与代码一起管理的工件来实施和维护的指南，通过结构化的项目文档实现一致的 AI 交互和团队协作。

## 何时使用此技能

- 使用 Conductor 设置新项目
- 理解上下文工件之间的关系
- 在 AI 辅助开发会话中保持一致性
- 让团队成员加入现有的 Conductor 项目
- 决定何时更新上下文文档
- 管理绿地项目与棕地项目的上下文

## 核心理念

上下文驱动开发将项目上下文视为与代码一起管理的一等工件。不依赖于临时的提示或分散的文档，而是建立一个持久的、结构化的基础来指导所有 AI 交互。

关键原则：

1. **上下文先于代码**：在实施之前定义要构建的内容和方式
2. **活性文档**：上下文工件随项目演进
3. **单一事实来源**：每种类型信息有一个规范位置
4. **AI 对齐**：一致的上下文产生一致的 AI 行为

## 工作流程

遵循**上下文 → 规范与计划 → 实施**工作流程：

1. **上下文阶段**：建立或验证项目上下文工件存在且是最新的
2. **规范阶段**：定义工作单元的需求和验收标准
3. **计划阶段**：将规范分解为分阶段的、可执行的任务
4. **实施阶段**：按照既定的工作流程模式执行任务

## 工件关系

### product.md - 定义是什么和为什么

目的：捕获产品愿景、目标、目标用户和业务上下文。

内容：

- 产品名称和一句话描述
- 问题陈述和解决方案方法
- 目标用户角色
- 核心功能和能力
- 成功指标和 KPI
- 产品路线图（高层次）

更新时机：

- 产品愿景或目标发生变化
- 计划新的主要功能
- 目标受众转变
- 业务优先级演进

### product-guidelines.md - 定义如何沟通

目的：建立品牌语气、消息传递标准和沟通模式。

内容：

- 品牌语气和语调指南
- 术语和词汇表
- 错误消息约定
- 面向用户的文案标准
- 文档风格

更新时机：

- 品牌指南发生变化
- 引入新术语
- 沟通模式需要完善

### tech-stack.md - 定义用什么

目的：记录技术选择、依赖项和架构决策。

内容：

- 主要语言和框架
- 关键依赖项及版本
- 基础设施和部署目标
- 开发工具和环境
- 测试框架
- 代码质量工具

更新时机：

- 添加新依赖项
- 升级主要版本
- 更改基础设施
- 采用新工具或模式

### workflow.md - 定义如何工作

目的：建立开发实践、质量门和团队工作流程。

内容：

- 开发方法论（TDD 等）
- Git 工作流程和提交约定
- 代码审查要求
- 测试要求和覆盖率目标
- 质量保证门
- 部署程序

更新时机：

- 团队实践演进
- 质量标准发生变化
- 采用新的工作流程模式

### tracks.md - 跟踪正在发生的事情

目的：所有工作单元的注册表，包含状态和元数据。

内容：

- 带有当前状态的活跃 tracks
- 带有完成日期的已完成 tracks
- Track 元数据（类型、优先级、负责人）
- 指向各个 track 目录的链接

更新时机：

- 创建新 tracks
- Track 状态变化
- Tracks 完成或归档

## 上下文维护原则

### 保持工件同步

确保一个工件中的更改反映在相关文档中：

- product.md 中的新功能 → 如果需要新依赖项，更新 tech-stack.md
- 已完成的 track → 更新 product.md 以反映新能力
- 工作流程变更 → 更新所有受影响的 track 计划

### 添加依赖项时更新 tech-stack.md

添加任何新依赖项之前：

1. 检查现有依赖项是否解决需求
2. 记录新依赖项的理由
3. 添加版本约束
4. 注明任何配置要求

### 功能完成时更新 product.md

完成功能 track 后：

1. 将 product.md 中的功能从"计划"移动到"已实施"
2. 更新任何受影响的成功指标
3. 记录与原始计划的任何范围变更

### 实施前验证上下文

开始任何 track 之前：

1. 阅读所有上下文工件
2. 标记任何过时的信息
3. 在继续之前提议更新
4. 与利益相关者确认上下文准确性

## 绿地项目与棕地项目处理

### 绿地项目（新建）

对于新项目：

1. 运行 `/conductor:setup` 交互式创建所有工件
2. 回答关于产品愿景、技术偏好和工作流程的问题
3. 为所选语言生成初始风格指南
4. 创建空的 tracks 注册表

特点：

- 对上下文结构有完全控制
- 在代码存在之前定义标准
- 尽早建立模式

### 棕地项目（现有）

对于现有代码库：

1. 运行 `/conductor:setup` 进行现有代码库检测
2. 系统分析现有代码、配置和文档
3. 基于发现的模式预填充工件
4. 审查和完善生成的上下文

特点：

- 从现有代码中提取隐式上下文
- 调和现有模式与期望模式
- 记录技术债务和现代化计划
- 在建立标准的同时保留有效模式

## 好处

### 团队协作

- 新团队成员通过明确的上下文更快入门
- 整个团队一致的术语和约定
- 对产品目标和技术决策的共识理解

### AI 一致性

- AI 助手在会话间产生一致的输出
- 减少在每次交互中重新解释上下文的需要
- 基于记录的标准的行为可预测

### 组织记忆

- 决策和理由得到保留
- 上下文在团队变化中幸存
- 历史上下文为未来决策提供信息

### 质量保证

- 标准是明确且可验证的
- 偏离上下文是可检测的
- 质量门被记录且可强制执行

## 目录结构

```
conductor/
├── index.md              # 链接所有工件的导航中心
├── product.md            # 产品愿景和目标
├── product-guidelines.md # 沟通标准
├── tech-stack.md         # 技术偏好
├── workflow.md           # 开发实践
├── tracks.md             # 工作单元注册表
├── setup_state.json      # 可恢复的设置状态
├── code_styleguides/     # 特定语言的约定
│   ├── python.md
│   ├── typescript.md
│   └── ...
└── tracks/
    └── <track-id>/
        ├── spec.md
        ├── plan.md
        ├── metadata.json
        └── index.md
```

## 上下文生命周期

1. **创建**：通过 `/conductor:setup` 进行初始设置
2. **验证**：在每个 track 之前验证
3. **演进**：随项目增长更新
4. **同步**：保持工件对齐
5. **归档**：记录历史决策

## 上下文验证检查清单

在任何 track 上开始实施之前，验证上下文：

### 产品上下文

- [ ] product.md 反映当前产品愿景
- [ ] 准确描述目标用户
- [ ] 功能列表是最新的
- [ ] 定义了成功指标

### 技术上下文

- [ ] tech-stack.md 列出所有当前依赖项
- [ ] 版本号准确
- [ ] 基础设施目标正确
- [ ] 记录了开发工具

### 工作流程上下文

- [ ] workflow.md 描述当前实践
- [ ] 定义了质量门
- [ ] 指定了覆盖率目标
- [ ] 记录了提交约定

### Track 上下文

- [ ] tracks.md 显示所有活跃工作
- [ ] 没有过时或废弃的 tracks
- [ ] 标注了 tracks 之间的依赖关系

## 常见反模式

避免这些上下文管理错误：

### 过时上下文

问题：上下文文档变得过时且具有误导性。
解决方案：将上下文更新作为每个 track 完成过程的一部分。

### 上下文蔓延

问题：信息分散在多个位置。
解决方案：使用定义的工件结构；避免创建新文档类型。

### 隐式上下文

问题：依赖于未在工件中捕获的知识。
解决方案：如果您重复引用某些内容，请将其添加到适当的工件中。

### 上下文囤积

问题：一个人在没有团队输入的情况下维护上下文。
解决方案：在拉取请求中审查上下文工件；使更新成为协作过程。

### 过度规范

问题：上下文变得如此详细以至于无法维护。
解决方案：保持工件专注于影响 AI 行为和团队协作的决策。

## 与开发工具集成

### IDE 集成

配置您的 IDE 显式显示上下文文件：

- 固定 conductor/product.md 以供快速参考
- 将 tech-stack.md 添加到项目笔记
- 从风格指南中为常见模式创建代码片段

### Git 钩子

考虑预提交钩子：

- 当依赖项更改而未更新 tech-stack.md 时发出警告
- 当功能分支合并时提醒更新 product.md
- 验证上下文工件语法

### CI/CD 集成

在管道中包含上下文验证：

- 检查 tech-stack.md 与实际依赖项匹配
- 验证上下文文档中的链接可解析
- 确保 tracks.md 状态与 git 分支状态匹配

## 会话连续性

Conductor 通过上下文持久性支持多会话开发：

### 开始新会话

1. 阅读 index.md 以定位自己
2. 检查 tracks.md 以了解活跃工作
3. 查看相关 track 的 plan.md 以了解当前任务
4. 验证上下文工件是最新的

### 结束会话

1. 使用当前进度更新 plan.md
2. 注明任何阻塞项或所做的决策
3. 使用清晰状态提交进行中的工作
4. 如果状态发生变化，更新 tracks.md

### 处理中断

如果在任务中途被中断：

1. 将任务标记为 `[~]` 并注明停止点
2. 将工作进行中提交到功能分支
3. 在 plan.md 中记录任何未提交的决策

## 最佳实践

1. **首先阅读上下文**：在开始工作之前始终阅读相关工件
2. **小更新**：进行增量上下文更改，而不是大规模重写
3. **链接决策**：在做出实施选择时引用上下文
4. **版本化上下文**：与代码更改一起提交上下文更改
5. **审查上下文**：在代码审查中包括上下文工件审查
6. **定期验证**：在主要工作之前运行上下文验证检查清单
7. **沟通更改**：当上下文工件发生重大变化时通知团队
8. **保留历史**：使用 git 跟踪上下文随时间的演进
9. **质疑过时**：如果上下文感觉不对，调查并更新
10. **保持可操作**：每个上下文项目都应该为决策或行为提供信息
