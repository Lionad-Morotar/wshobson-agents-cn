---
name: workflow-orchestration-patterns
description: 使用 Temporal 为分布式系统设计持久工作流。涵盖工作流与活动的分离、Saga 模式、状态管理和确定性约束。在构建长时间运行的流程、分布式事务或微服务编排时使用。
---

# 工作流编排模式

掌握使用 Temporal 的工作流编排架构，涵盖基本设计决策、弹性模式和构建可靠分布式系统的最佳实践。

## 何时使用工作流编排

### 理想用例（来源：docs.temporal.io）

- **多步骤流程**跨越机器/服务/数据库
- **分布式事务**要求全有或全无语义
- **长时间运行的工作流**（小时到年）自动状态持久化
- **故障恢复**必须从最后成功步骤恢复
- **业务流程**：预订、订单、营销活动、审批
- **实体生命周期管理**：库存跟踪、账户管理、购物车工作流
- **基础设施自动化**：CI/CD 管道、资源调配、部署
- **人工参与**系统需要超时和升级

### 何时不使用

- 简单 CRUD 操作（使用直接 API 调用）
- 纯数据处理管道（使用 Airflow、批处理）
- 无状态请求/响应（使用标准 API）
- 实时流（使用 Kafka、事件处理器）

## 关键设计决策：工作流 vs 活动

**基本规则**（来源：temporal.io/blog/workflow-engine-principles）：

- **工作流** = 编排逻辑和决策制定
- **活动** = 外部交互（API、数据库、网络调用）

### 工作流（编排）

**特点：**

- 包含业务逻辑和协调
- **必须确定性**（相同输入 → 相同输出）
- **不能**执行直接外部调用
- 跨故障自动保存状态
- 尽管基础设施故障也可运行多年

**示例工作流任务：**

- 决定执行哪些步骤
- 处理补偿逻辑
- 管理超时和重试
- 协调子工作流

### 活动（外部交互）

**特点：**

- 处理所有外部系统交互
- 可非确定性（API 调用、DB 写入）
- 包括内置超时和重试逻辑
- **必须幂等**（调用 N 次 = 调用一次）
- 短期（通常秒到分钟）

**示例活动任务：**

- 调用支付网关 API
- 写入数据库
- 发送电子邮件或通知
- 查询外部服务

### 设计决策框架

```
是否涉及外部系统？ → 活动
是否是编排/决策逻辑？ → 工作流
```

## 核心工作流模式

### 1. Saga 模式与补偿

**目的**：实现具有回滚能力的分布式事务

**模式**（来源：temporal.io/blog/compensating-actions-part-of-a-complete-breakfast-with-sagas）：

```
对于每个步骤：
  1. 执行前注册补偿
  2. 执行步骤（通过活动）
  3. 失败时，按相反顺序运行所有补偿（LIFO）
```

**示例：支付工作流**

1. 预留库存（补偿：释放库存）
2. 收取支付（补偿：退款）
3. 履行订单（补偿：取消履行）

**关键要求：**

- 补偿必须幂等
- 执行步骤前注册补偿
- 按相反顺序运行补偿
- 优雅处理部分故障

### 2. 实体工作流（Actor 模型）

**目的**：表示单个实体实例的长期工作流

**模式**（来源：docs.temporal.io/evaluate/use-cases-design-patterns）：

- 一个工作流执行 = 一个实体（购物车、账户、库存项）
- 工作流在实体生命周期内持久化
- 接收状态变更信号
- 支持查询当前状态

**示例用例：**

- 购物车（添加商品、结账、过期）
- 银行账户（存款、取款、余额检查）
- 产品库存（库存更新、预订）

**优势：**

- 封装实体行为
- 保证每个实体的一致性
- 自然事件溯源

### 3. 扇出/扇入（并行执行）

**目的**：并行执行多个任务，聚合结果

**模式：**

- 生成子工作流或并行活动
- 等待所有完成
- 聚合结果
- 处理部分故障

**扩展规则**（来源：temporal.io/blog/workflow-engine-principles）：

- 不扩展单个工作流
- 对于 1M 任务：生成 1K 子工作流 × 每个 1K 任务
- 保持每个工作流有界

### 4. 异步回调模式

**目的**：等待外部事件或人工审批

**模式：**

- 工作流发送请求并等待信号
- 外部系统异步处理
- 发送信号恢复工作流
- 工作流继续响应

**用例：**

- 人工审批工作流
- Webhook 回调
- 长时间运行的外部流程

## 状态管理和确定性

### 自动状态保存

**Temporal 工作原理**（来源：docs.temporal.io/workflows）：

- 完整程序状态自动保存
- 事件历史记录每个命令和事件
- 从崩溃中无缝恢复
- 应用程序恢复故障前状态

### 确定性约束

**工作流作为状态机执行**：

- 重放行为必须一致
- 相同输入 → 每次相同输出

**工作流中禁止**（来源：docs.temporal.io/workflows）：

- ❌ 线程、锁、同步原语
- ❌ 随机数生成（`random()`）
- ❌ 全局状态或静态变量
- ❌ 系统时间（`datetime.now()`）
- ❌ 直接文件 I/O 或网络调用
- ❌ 非确定性库

**工作流中允许**：

- ✅ `workflow.now()`（确定性时间）
- ✅ `workflow.random()`（确定性随机）
- ✅ 纯函数和计算
- ✅ 调用活动（非确定性操作）

### 版本控制策略

**挑战**：在旧执行仍在运行时更改工作流代码

**解决方案**：

1. **版本控制 API**：使用 `workflow.get_version()` 进行安全更改
2. **新工作流类型**：创建新工作流，将新执行路由到它
3. **向后兼容**：确保旧事件正确重放

## 弹性和错误处理

### 重试策略

**默认行为**：Temporal 永远重试活动

**配置重试**：

- 初始重试间隔
- 退避系数（指数退避）
- 最大间隔（限制重试延迟）
- 最大尝试次数（最终失败）

**不可重试错误**：

- 无效输入（验证失败）
- 业务规则违规
- 永久故障（未找到资源）

### 幂等性要求

**为何关键**（来源：docs.temporal.io/activities）：

- 活动可能执行多次
- 网络故障触发重试
- 重复执行必须安全

**实现策略**：

- 幂等性键（去重）
- 使用唯一约束的检查-执行
- 更新插入操作而非插入
- 跟踪已处理的请求 ID

### 活动心跳

**目的**：检测停滞的长时间运行活动

**模式**：

- 活动发送周期性心跳
- 包括进度信息
- 未收到心跳时超时
- 支持基于进度的重试

## 最佳实践

### 工作流设计

1. **保持工作流专注** - 每个工作流单一职责
2. **小工作流** - 使用子工作流实现可扩展性
3. **明确边界** - 工作流编排，活动执行
4. **本地测试** - 使用时间跳过测试环境

### 活动设计

1. **幂等操作** - 可安全重试
2. **短期** - 秒到分钟，而非小时
3. **超时配置** - 始终设置超时
4. **长任务心跳** - 报告进度
5. **错误处理** - 区分可重试与不可重试

### 常见陷阱

**工作流违规**：

- 使用 `datetime.now()` 而非 `workflow.now()`
- 工作流代码中的线程或异步操作
- 直接从工作流调用外部 API
- 工作流中的非确定性逻辑

**活动错误**：

- 非幂等操作（无法处理重试）
- 缺少超时（活动永远运行）
- 无错误分类（重试验证错误）
- 忽略负载限制（每个参数 2MB）

### 运营考虑

**监控**：

- 工作流执行持续时间
- 活动故障率
- 重试尝试和退避
- 待处理工作流计数

**可扩展性**：

- 使用 Worker 水平扩展
- 任务队列分区
- 子工作流分解
- 适当的活动批处理

## 其他资源

**官方文档**：

- Temporal 核心概念：docs.temporal.io/workflows
- 工作流模式：docs.temporal.io/evaluate/use-cases-design-patterns
- 最佳实践：docs.temporal.io/develop/best-practices
- Saga 模式：temporal.io/blog/saga-pattern-made-easy

**关键原则**：

1. 工作流 = 编排，活动 = 外部调用
2. 确定性对工作流不可协商
3. 幂等性对活动至关重要
4. 状态保存是自动的
5. 为故障和恢复设计
