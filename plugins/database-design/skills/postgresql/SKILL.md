---
name: postgresql-table-design
description: 设计 PostgreSQL 特定的表结构。涵盖最佳实践、数据类型、索引、约束、性能模式和高级功能
---

# PostgreSQL 表设计

## 核心规则

- 为引用表（用户、订单等）定义**主键**。时序/事件/日志数据并非总是需要。使用时，优先选择 `BIGINT GENERATED ALWAYS AS IDENTITY`；仅在需要全局唯一性/不透明性时使用 `UUID`。
- **先规范化（到 3NF）**以消除数据冗余和更新异常；**仅**在经过测量、高 ROI 的读取且连接性能被证明有问题时才进行反规范化。过早反规范化会增加维护负担。
- 在语义需要的任何地方添加 **NOT NULL**；为常见值使用 **DEFAULT**。
- 为实际查询的访问路径**创建索引**：PK/unique（自动）、**FK 列（手动！）**、频繁过滤/排序和连接键。
- 优先选择事件时间使用 **TIMESTAMPTZ**；金额使用 **NUMERIC**；字符串使用 **TEXT**；整数值使用 **BIGINT**，浮点数使用 **DOUBLE PRECISION**（或 `NUMERIC` 用于精确的十进制算术）。

## PostgreSQL "陷阱"

- **标识符**：未加引号的 → 小写化。避免加引号/混合大小写的名称。约定：表/列名使用 `snake_case`。
- **UNIQUE + NULL**：UNIQUE 允许多个 NULL。使用 `UNIQUE (...) NULLS NOT DISTINCT`（PG15+）来限制只能有一个 NULL。
- **FK 索引**：PostgreSQL **不会**自动为 FK 列创建索引。需要手动添加。
- **无静默强制转换**：长度/精度溢出会报错（不会截断）。示例：向 `NUMERIC(2,0)` 插入 999 会失败并报错，不像某些数据库会静默截断或舍入。
- **序列/自增有间隙**（正常；不要"修复"）。回滚、崩溃和并发事务会在 ID 序列中产生间隙（1, 2, 5, 6...）。这是预期行为——不要试图使 ID 连续。
- **堆存储**：默认没有聚集主键（不像 SQL Server/MySQL InnoDB）；`CLUSTER` 是一次性重组，不会在后续插入时维护。磁盘上的行顺序是插入顺序，除非显式聚集。
- **MVCC**：更新/删除会留下死元组；vacuum 会处理它们——设计应避免频繁的宽行更新。

## 数据类型

- **ID**：优先选择 `BIGINT GENERATED ALWAYS AS IDENTITY`（`GENERATED BY DEFAULT` 也可以）；在合并/联合/分布式系统中使用或用于不透明 ID 时使用 `UUID`。使用 `uuidv7()` 生成（如果使用 PG18+ 则优先选择）或 `gen_random_uuid()`（如果使用较旧的 PG 版本）。
- **整数**：优先选择 `BIGINT`，除非存储空间关键；较小范围使用 `INTEGER`；避免 `SMALLINT`，除非有约束。
- **浮点数**：优先选择 `DOUBLE PRECISION` 而非 `REAL`，除非存储空间关键。使用 `NUMERIC` 进行精确的十进制算术。
- **字符串**：优先选择 `TEXT`；如果需要长度限制，使用 `CHECK (LENGTH(col) <= n)` 而非 `VARCHAR(n)`；避免 `CHAR(n)`。二进制数据使用 `BYTEA`。大字符串/二进制（>2KB 默认阈值）会自动以压缩方式存储在 TOAST 中。TOAST 存储：`PLAIN`（无 TOAST）、`EXTENDED`（压缩 + 行外）、`EXTERNAL`（行外，不压缩）、`MAIN`（压缩，尽可能保留在行内）。默认 `EXTENDED` 通常是最优的。使用 `ALTER TABLE tbl ALTER COLUMN col SET STORAGE strategy` 和 `ALTER TABLE tbl SET (toast_tuple_target = 4096)` 控制阈值。不区分大小写：对于区域设置/重音处理使用非确定性排序规则；对于纯 ASCII 使用 `LOWER(col)` 上的表达式索引（优先选择，除非列需要不区分大小写的 PK/FK/UNIQUE）或 `CITEXT`。
- **金额**：`NUMERIC(p,s)`（绝不使用浮点数）。
- **时间**：时间戳使用 `TIMESTAMPTZ`；仅日期使用 `DATE`；持续时间使用 `INTERVAL`。避免 `TIMESTAMP`（不带时区）。使用 `now()` 获取事务开始时间，`clock_timestamp()` 获取当前挂钟时间。
- **布尔值**：`BOOLEAN` 带 `NOT NULL` 约束，除非需要三态值。
- **枚举**：`CREATE TYPE ... AS ENUM` 用于小型、稳定集合（例如美国州、星期几）。对于业务逻辑驱动和演进的值（例如订单状态）→ 使用 TEXT（或 INT）+ CHECK 或查找表。
- **数组**：`TEXT[]`、`INTEGER[]` 等。用于需要查询元素的有序列表。使用 **GIN** 索引进行包含（`@>`、`<@`）和重叠（`&&`）查询。访问：`arr[1]`（1 索引）、`arr[1:3]`（切片）。适用于标签、类别；避免用于关系——改用连接表。字面量语法：`'{val1,val2}'` 或 `ARRAY[val1,val2]`。
- **范围类型**：`daterange`、`numrange`、`tstzrange` 用于区间。支持重叠（`&&`）、包含（`@>`）运算符。使用 **GiST** 索引。适用于调度、版本控制、数值范围。选择边界方案并一致使用；默认优先选择 `[)`（包含/不包含）。
- **网络类型**：`INET` 用于 IP 地址，`CIDR` 用于网络范围，`MACADDR` 用于 MAC 地址。支持网络运算符（`<<`、`>>`、`&&`）。
- **几何类型**：`POINT`、`LINE`、`POLYGON`、`CIRCLE` 用于 2D 空间数据。使用 **GiST** 索引。对于高级空间功能，考虑 **PostGIS**。
- **文本搜索**：`TSVECTOR` 用于全文搜索文档，`TSQUERY` 用于搜索查询。使用 **GIN** 索引 `tsvector`。始终指定语言：`to_tsvector('english', col)` 和 `to_tsquery('english', 'query')`。绝不使用单参数版本。这适用于索引表达式和查询。
- **域类型**：`CREATE DOMAIN email AS TEXT CHECK (VALUE ~ '^[^@]+@[^@]+$')` 用于带验证的可重用自定义类型。跨表强制约束。
- **复合类型**：`CREATE TYPE address AS (street TEXT, city TEXT, zip TEXT)` 用于列内的结构化数据。使用 `(col).field` 语法访问。
- **JSONB**：优先于 JSON；使用 **GIN** 索引。仅用于可选/半结构化属性。仅在必须保留内容的原始顺序时才使用 JSON。
- **向量类型**：`pgvector` 提供的 `vector` 类型，用于嵌入的向量相似性搜索。

### 不要使用以下数据类型

- 不要使用 `timestamp`（不带时区）；要使用 `timestamptz`。
- 不要使用 `char(n)` 或 `varchar(n)`；要使用 `text`。
- 不要使用 `money` 类型；要使用 `numeric`。
- 不要使用 `timetz` 类型；要使用 `timestamptz`。
- 不要使用 `timestamptz(0)` 或任何其他精度规范；要使用 `timestamptz`。
- 不要使用 `serial` 类型；要使用 `generated always as identity`。

## 表类型

- **REGULAR**：默认；完全持久化，有日志。
- **TEMPORARY**：会话范围，自动删除，无日志。用于临时工作更快。
- **UNLOGGED**：持久化但不是崩溃安全的。写入更快；适用于缓存/暂存。

## 行级安全

使用 `ALTER TABLE tbl ENABLE ROW LEVEL SECURITY` 启用。创建策略：`CREATE POLICY user_access ON orders FOR SELECT TO app_users USING (user_id = current_user_id())`。内置的基于用户行级访问控制。

## 约束

- **PK**：隐式 UNIQUE + NOT NULL；创建 B-tree 索引。
- **FK**：指定 `ON DELETE/UPDATE` 操作（`CASCADE`、`RESTRICT`、`SET NULL`、`SET DEFAULT`）。在引用列上添加显式索引——加速连接并防止父删除/更新时的锁定问题。使用 `DEFERRABLE INITIALLY DEFERRED` 用于在事务结束时检查的循环 FK 依赖。
- **UNIQUE**：创建 B-tree 索引；允许多个 NULL，除非使用 `NULLS NOT DISTINCT`（PG15+）。标准行为：`(1, NULL)` 和 `(1, NULL)` 被允许。使用 `NULLS NOT DISTINCT`：只允许一个 `(1, NULL)`。优先选择 `NULLS NOT DISTINCT`，除非您特别需要重复的 NULL。
- **CHECK**：行本地约束；NULL 值通过检查（三值逻辑）。示例：`CHECK (price > 0)` 允许 NULL 价格。结合 `NOT NULL` 强制执行：`price NUMERIC NOT NULL CHECK (price > 0)`。
- **EXCLUDE**：使用运算符防止重叠值。`EXCLUDE USING gist (room_id WITH =, booking_period WITH &&)` 防止房间重复预订。需要适当的索引类型（通常是 GiST）。

## 索引

- **B-tree**：等值/范围查询的默认选择（`=`、`<`、`>`、`BETWEEN`、`ORDER BY`）
- **复合索引**：顺序很重要——如果在最左边前缀上等值则使用索引（`WHERE a = ? AND b > ?` 使用 `(a,b)` 上的索引，但 `WHERE b = ?` 不使用）。将最具选择性/频繁过滤的列放在前面。
- **覆盖索引**：`CREATE INDEX ON tbl (id) INCLUDE (name, email)` - 包含非键列用于仅索引扫描而不访问表。
- **部分索引**：用于热点子集（`WHERE status = 'active'` → `CREATE INDEX ON tbl (user_id) WHERE status = 'active'`）。任何带有 `status = 'active'` 的查询都可以使用此索引。
- **表达式索引**：用于计算搜索键（`CREATE INDEX ON tbl (LOWER(email))`）。表达式必须与 WHERE 子句中的完全匹配：`WHERE LOWER(email) = 'user@example.com'`。
- **GIN**：JSONB 包含/存在、数组（`@>`、`?`）、全文搜索（`@@`）
- **GiST**：范围、几何、排除约束
- **BRIN**：非常大的自然有序数据（时序）——最小存储开销。当磁盘上的行顺序与索引列相关时有效（插入顺序或 `CLUSTER` 后）。

## 分区

- 用于非常大的表（>1 亿行），其中查询始终在分区键上过滤（通常是时间/日期）。
- 替代用法：用于数据维护任务规定的表，例如定期修剪或批量替换数据
- **RANGE**：时序常见（`PARTITION BY RANGE (created_at)`）。创建分区：`CREATE TABLE logs_2024_01 PARTITION OF logs FOR VALUES FROM ('2024-01-01') TO ('2024-02-01')`。**TimescaleDB** 自动执行基于时间或 ID 的分区，具有保留策略和压缩。
- **LIST**：用于离散值（`PARTITION BY LIST (region)`）。示例：`FOR VALUES IN ('us-east', 'us-west')`。
- **HASH**：当没有自然键时均匀分布（`PARTITION BY HASH (user_id)`）。使用模数创建 N 个分区。
- **约束排除**：需要分区上的 `CHECK` 约束以供查询 planner 修剪。为声明式分区自动创建（PG10+）。
- 优先选择声明式分区或超表。不要使用表继承。
- **限制**：没有全局 UNIQUE 约束——在 PK/UNIQUE 中包含分区键。不支持从分区表的 FK；使用触发器。

## 特殊考虑

### 频繁更新的表

- **分离热/冷列**——将频繁更新的列放在单独的表中以最小化膨胀。
- **使用 `fillfactor=90`** 留出空间进行避免索引维护的 HOT 更新。
- **避免更新索引列**——阻止有益的 HOT 更新。
- **按更新模式分区**——将频繁更新的行与稳定数据分离在不同的分区中。

### 频繁插入的工作负载

- **最小化索引**——仅创建您查询的索引；每个索引都会减慢插入。
- **使用 `COPY` 或多行 `INSERT`** 而非单行插入。
- **UNLOGGED 表**用于可重建的暂存数据——写入快得多。
- **延迟索引创建**用于批量加载——>删除索引，加载数据，重新创建索引。
- **按时间/哈希分区**以分散负载。**TimescaleDB** 自动执行频繁插入数据的分区和压缩。
- **为主键使用自然键**，例如（时间戳、device_id），如果强制全局唯一性很重要，许多频繁插入的表根本不需要主键。
- 如果您确实需要代理键，**优先选择 `BIGINT GENERATED ALWAYS AS IDENTITY` 而非 `UUID`**。

### Upsert 友好设计

- **冲突目标列需要 UNIQUE 索引**——`ON CONFLICT (col1, col2)` 需要精确匹配的唯一索引（部分索引不起作用）。
- **使用 `EXCLUDED.column`**引用将要插入的值；仅更新实际更改的列以减少写入开销。
- **`DO NOTHING` 比 `DO UPDATE` 更快**，当不需要实际更新时。

### 安全架构演进

- **事务性 DDL**：大多数 DDL 操作可以在事务中运行并回滚——`BEGIN; ALTER TABLE...; ROLLBACK;` 用于安全测试。
- **并发索引创建**：`CREATE INDEX CONCURRENTLY` 避免阻塞写入，但不能在事务中运行。
- **易失性默认值导致重写**：添加带有易失性默认值的 `NOT NULL` 列（例如，`now()`、`gen_random_uuid()`）会重写整个表。非易失性默认值很快。
- **先删除约束再删除列**：`ALTER TABLE DROP CONSTRAINT` 然后 `DROP COLUMN` 以避免依赖问题。
- **函数签名更改**：`CREATE OR REPLACE` 带有不同参数会创建重载，而非替换。如果不需要重载，则删除旧版本。

## 生成列

- `... GENERATED ALWAYS AS (<expr>) STORED` 用于计算的、可索引的字段。PG18+ 添加 `VIRTUAL` 列（读取时计算，不存储）。

## 扩展

- **`pgcrypto`**：`crypt()` 用于密码哈希。
- **`uuid-ossp`**：替代 UUID 函数；新项目优先选择 `pgcrypto`。
- **`pg_trgm`**：使用 `%` 运算符、`similarity()` 函数的模糊文本搜索。使用 GIN 索引加速 `LIKE '%pattern%'`。
- **`citext`**：不区分大小写的文本类型。优先选择 `LOWER(col)` 上的表达式索引，除非您需要不区分大小写的约束。
- **`btree_gin`/`btree_gist`**：启用混合类型索引（例如，在 JSONB 和文本列上都使用 GIN 索引）。
- **`hstore`**：键值对；大部分被 JSONB 取代，但可用于简单的字符串映射。
- **`timescaledb`**：时序必需——自动分区、保留、压缩、连续聚合。
- **`postgis`**：超越基本几何类型的全面地理空间支持——基于位置的应用必需。
- **`pgvector`**：嵌入的向量相似性搜索。
- **`pgaudit`**：所有数据库活动的审计日志。

## JSONB 指南

- 优先选择带 **GIN** 索引的 `JSONB`。
- 默认：`CREATE INDEX ON tbl USING GIN (jsonb_col);` → 加速：
  - **包含** `jsonb_col @> '{"k":"v"}'`
  - **键存在** `jsonb_col ? 'k'`，**任意/所有键** `?\|`、`?&`
  - 嵌套文档上的**路径包含**
  - **析取** `jsonb_col @> ANY(ARRAY['{"status":"active"}', '{"status":"pending"}'])`
- 重度 `@>` 工作负载：考虑操作符类 `jsonb_path_ops` 以获得更小/更快的仅包含索引：
  - `CREATE INDEX ON tbl USING GIN (jsonb_col jsonb_path_ops);`
  - **权衡**：失去对键存在（`?`、`?|`、`?&`）查询的支持——仅支持包含（`@>`）
- 特定标量字段上的等值/范围：提取并使用 B-tree 索引（生成列或表达式）：
  - `ALTER TABLE tbl ADD COLUMN price INT GENERATED ALWAYS AS ((jsonb_col->>'price')::INT) STORED;`
  - `CREATE INDEX ON tbl (price);`
  - 优先选择像 `WHERE price BETWEEN 100 AND 500`（使用 B-tree）的查询，而非没有索引的 `WHERE (jsonb_col->>'price')::INT BETWEEN 100 AND 500`。
- JSONB 内的数组：使用 GIN + `@>` 进行包含（例如，标签）。如果仅进行包含，考虑 `jsonb_path_ops`。
- 将核心关系保留在表中；使用 JSONB 用于可选/可变属性。
- 使用约束限制列中允许的 JSONB 值，例如 `config JSONB NOT NULL CHECK(jsonb_typeof(config) = 'object')`

## 示例

### 用户

```sql
CREATE TABLE users (
  user_id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  email TEXT NOT NULL UNIQUE,
  name TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE UNIQUE INDEX ON users (LOWER(email));
CREATE INDEX ON users (created_at);
```

### 订单

```sql
CREATE TABLE orders (
  order_id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  user_id BIGINT NOT NULL REFERENCES users(user_id),
  status TEXT NOT NULL DEFAULT 'PENDING' CHECK (status IN ('PENDING','PAID','CANCELED')),
  total NUMERIC(10,2) NOT NULL CHECK (total > 0),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX ON orders (user_id);
CREATE INDEX ON orders (created_at);
```

### JSONB

```sql
CREATE TABLE profiles (
  user_id BIGINT PRIMARY KEY REFERENCES users(user_id),
  attrs JSONB NOT NULL DEFAULT '{}',
  theme TEXT GENERATED ALWAYS AS (attrs->>'theme') STORED
);
CREATE INDEX profiles_attrs_gin ON profiles USING GIN (attrs);
```
